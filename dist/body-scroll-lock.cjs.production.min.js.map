{"version":3,"file":"body-scroll-lock.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["// Adopted and modified solution from Bohdan Didukh (2017)\n// https://stackoverflow.com/questions/41594997/ios-10-safari-prevent-scrolling-behind-a-fixed-overlay-and-maintain-scroll-posi\n\nexport interface BodyScrollOptions {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  reserveScrollBarGap?: boolean\n  allowTouchMove?: (el: any) => boolean\n}\n\ninterface Lock {\n  targetElement: any\n  options: BodyScrollOptions\n}\n\n// Older browsers don't support event options, feature detect it.\nlet hasPassiveEvents = false\nif (typeof window !== 'undefined') {\n  const passiveTestOptions = {\n    get passive() {\n      hasPassiveEvents = true\n      return undefined\n    },\n  }\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  const listener = (): void => {}\n  window.addEventListener('testPassive', listener, passiveTestOptions)\n  window.removeEventListener(\n    'testPassive',\n    listener,\n    passiveTestOptions as EventListenerOptions\n  )\n}\n\nconst isIosDevice =\n  typeof window !== 'undefined' &&\n  window.navigator &&\n  window.navigator.platform &&\n  (/iP(ad|hone|od)/.test(window.navigator.platform) ||\n    (window.navigator.platform === 'MacIntel' &&\n      window.navigator.maxTouchPoints > 1))\ntype HandleScrollEvent = TouchEvent\n\nlet locks: Lock[] = []\nlet documentListenerAdded = false\nlet initialClientY = -1\nlet previousBodyOverflowSetting: string | undefined\nlet previousBodyPaddingRight: string | undefined\n\n// returns true if `el` should be allowed to receive touchmove events.\nconst allowTouchMove = (el: EventTarget | null): boolean =>\n  locks.some(\n    lock => lock.options.allowTouchMove && lock.options.allowTouchMove(el)\n  )\n\nconst preventDefault = (rawEvent: HandleScrollEvent): boolean => {\n  const e = rawEvent || (window.event as HandleScrollEvent)\n\n  // For the case whereby consumers adds a touchmove event listener to document.\n  // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })\n  // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then\n  // the touchmove event on document will break.\n  if (allowTouchMove(e.target)) {\n    return true\n  }\n\n  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).\n  if (e.touches.length > 1) return true\n\n  if (e.preventDefault) e.preventDefault()\n\n  return false\n}\n\nconst setOverflowHidden = (options?: BodyScrollOptions): void => {\n  // If previousBodyPaddingRight is already set, don't set it again.\n  if (previousBodyPaddingRight === undefined) {\n    const reserveScrollBarGap =\n      !!options && options.reserveScrollBarGap === true\n    const scrollBarGap =\n      window.innerWidth - document.documentElement.clientWidth\n\n    if (reserveScrollBarGap && scrollBarGap > 0) {\n      const computedBodyPaddingRight = parseInt(\n        window\n          .getComputedStyle(document.body)\n          .getPropertyValue('padding-right'),\n        10\n      )\n      previousBodyPaddingRight = document.body.style.paddingRight\n      document.body.style.paddingRight = `${computedBodyPaddingRight +\n        scrollBarGap}px`\n    }\n  }\n\n  // If previousBodyOverflowSetting is already set, don't set it again.\n  if (previousBodyOverflowSetting === undefined) {\n    previousBodyOverflowSetting = document.body.style.overflow\n    document.body.style.overflow = 'hidden'\n  }\n}\n\nconst restoreOverflowSetting = (): void => {\n  if (previousBodyPaddingRight !== undefined) {\n    document.body.style.paddingRight = previousBodyPaddingRight\n\n    // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it\n    // can be set again.\n    previousBodyPaddingRight = undefined\n  }\n\n  if (previousBodyOverflowSetting !== undefined) {\n    document.body.style.overflow = previousBodyOverflowSetting\n\n    // Restore previousBodyOverflowSetting to undefined\n    // so setOverflowHidden knows it can be set again.\n    previousBodyOverflowSetting = undefined\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions\nconst isTargetElementTotallyScrolled = (targetElement: any): boolean =>\n  targetElement\n    ? targetElement.scrollHeight - targetElement.scrollTop <=\n      targetElement.clientHeight\n    : false\n\nconst handleScroll = (\n  event: HandleScrollEvent,\n  targetElement: any\n): boolean => {\n  const clientY = event.targetTouches[0].clientY - initialClientY\n\n  if (allowTouchMove(event.target)) {\n    return false\n  }\n\n  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {\n    // element is at the top of its scroll.\n    return preventDefault(event)\n  }\n\n  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {\n    // element is at the bottom of its scroll.\n    return preventDefault(event)\n  }\n\n  event.stopPropagation()\n  return true\n}\n\nexport const disableBodyScroll = (\n  targetElement: any,\n  options?: BodyScrollOptions\n): void => {\n  // targetElement must be provided\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.'\n    )\n    return\n  }\n\n  // disableBodyScroll must not have been called on this targetElement before\n  if (locks.some(lock => lock.targetElement === targetElement)) {\n    return\n  }\n\n  const lock = {\n    targetElement,\n    options: options || {},\n  }\n\n  locks = [...locks, lock]\n\n  setOverflowHidden(options)\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = (event: HandleScrollEvent) => {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        initialClientY = event.targetTouches[0].clientY\n      }\n    }\n    targetElement.ontouchmove = (event: HandleScrollEvent) => {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        handleScroll(event, targetElement)\n      }\n    }\n\n    if (!documentListenerAdded) {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      document.addEventListener(\n        'touchmove',\n        preventDefault,\n        hasPassiveEvents ? { passive: false } : undefined\n      )\n      documentListenerAdded = true\n    }\n  }\n}\n\nexport const clearAllBodyScrollLocks = (): void => {\n  restoreOverflowSetting()\n\n  if (isIosDevice) {\n    // Clear all locks ontouchstart/ontouchmove handlers, and the references.\n    locks.forEach((lock: Lock) => {\n      lock.targetElement.ontouchstart = null\n      lock.targetElement.ontouchmove = null\n    })\n\n    if (documentListenerAdded) {\n      document.removeEventListener(\n        'touchmove',\n        preventDefault,\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        hasPassiveEvents\n          ? ({ passive: false } as EventListenerOptions)\n          : undefined\n      )\n      documentListenerAdded = false\n    }\n\n    // Reset initial clientY.\n    initialClientY = -1\n  }\n\n  locks = []\n}\n\nexport const enableBodyScroll = (targetElement: any): void => {\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.'\n    )\n    return\n  }\n\n  locks = locks.filter(lock => lock.targetElement !== targetElement)\n\n  if (!locks.length) {\n    restoreOverflowSetting()\n  }\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = null\n    targetElement.ontouchmove = null\n\n    if (documentListenerAdded && locks.length === 0) {\n      document.removeEventListener(\n        'touchmove',\n        preventDefault,\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        hasPassiveEvents\n          ? ({ passive: false } as EventListenerOptions)\n          : undefined\n      )\n      documentListenerAdded = false\n    }\n  }\n}\n"],"names":["hasPassiveEvents","window","passiveTestOptions","listener","addEventListener","removeEventListener","previousBodyOverflowSetting","previousBodyPaddingRight","isIosDevice","navigator","platform","test","maxTouchPoints","locks","documentListenerAdded","initialClientY","allowTouchMove","el","some","lock","options","preventDefault","rawEvent","e","event","target","touches","length","restoreOverflowSetting","undefined","document","body","style","paddingRight","overflow","forEach","targetElement","ontouchstart","ontouchmove","passive","scrollBarGap","innerWidth","documentElement","clientWidth","reserveScrollBarGap","computedBodyPaddingRight","parseInt","getComputedStyle","getPropertyValue","setOverflowHidden","targetTouches","clientY","scrollTop","scrollHeight","clientHeight","isTargetElementTotallyScrolled","stopPropagation","handleScroll","console","error","filter"],"mappings":"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"}